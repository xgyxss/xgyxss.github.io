<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="flutter状态管理之四大消费者使用分析"><meta name="keywords" content="202205,flutter"><meta name="author" content="夜行书生"><meta name="copyright" content="夜行书生"><title>flutter状态管理之四大消费者使用分析 | 夜行书生</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8fb1a251f70004c1a430fb7c57039651";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-W160D972F6', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"QOO2KQWBJ0","apiKey":"993ede762c7225acd4669201a2ab1dca","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.1.0'
} </script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="夜行书生" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider-of"><span class="toc-text">Provider.of</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer"><span class="toc-text">Consumer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector"><span class="toc-text">Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InheritedContext"><span class="toc-text">InheritedContext</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9ABuildContext"><span class="toc-text">扩展：BuildContext</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://cdn.jsdelivr.net/gh/xgyxss/picgo@main/img/hexo/github-avatar.jpeg"></div><div class="author-info__name text-center">夜行书生</div><div class="author-info__description text-center">生命的价值不在于能活多少天，而在于我们如何利用这些日子。</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/xgyxss">交个朋友吧</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">31</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">友链</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://github.com">Github</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.youtube.com">YouTube</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.instagram.com">Instagram</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://www.twitter.com">Twitter</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/xgyxss/picgo@main/img/hexo/hexo-bg.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">夜行书生</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/guestbook">留言板</a><a class="site-page" href="/history">运营历史</a><a class="site-page" href="/about">关于作者</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">flutter状态管理之四大消费者使用分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 29 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>出于好奇，翻看了一下源码以及源码注释文档，文中仅摘取了注释文档部分。</p>
<blockquote>
<p>rf.</p>
<p><a target="_blank" rel="noopener" href="https://www.liujunmin.com/flutter/provider/consumer.html">Flutter Provider状态管理—四种消费者使用分析</a> （文中的例子很详细）</p>
<p><a href="pub.dev">pub.dev</a></p>
</blockquote>
<p>文末，额外对源码注释中涉及到的<a href="#target2">BuildContext</a>部分进行了直译与总结。</p>
<span id="more"></span>

<h4 id="Provider-of"><a href="#Provider-of" class="headerlink" title="Provider.of"></a>Provider.of</h4><p><code>Provider.of&lt;T&gt;(context)</code>是<code>Provider</code>为我们提供的静态方法，当我们使用该方法去获取值的时候会返回查找到的最近的<code>T</code>类型的<code>provider</code>给我们，而且也不会遍历整个组件树。</p>
<blockquote>
<p>sc.</p>
<p>provider.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tried to listen to a value exposed <span class="keyword">with</span> provider, from outside of the widget tree.</span><br><span class="line"></span><br><span class="line">This <span class="keyword">is</span> likely caused by an event handler (like a button<span class="string">&#x27;s onPressed) that called</span></span><br><span class="line"><span class="string">Provider.of without passing `listen: false`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To fix, write:</span></span><br><span class="line"><span class="string">Provider.of&lt;<span class="subst">$T</span>&gt;(context, listen: false);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">It is unsupported because may pointlessly rebuild the widget associated to the</span></span><br><span class="line"><span class="string">event handler, when the widget tree doesn&#x27;</span>t care about the value.</span><br><span class="line"></span><br><span class="line">The context used was: $context</span><br></pre></td></tr></table></figure>

<p>试图从widget树之外监听一个用provider暴露的值。</p>
<p>这可能是由一个事件处理程序（比如按钮的onPressed）在没有传递<code>Listen:false</code>的情况下调用<code>Provider.of</code>造成的。</p>
<p>要解决这个问题，请写：</p>
<p><code>Provider.of&lt;$T&gt;(context, listen: false);</code></p>
<p>这是不被支持的，因为它可能会毫无意义地重建与事件处理程序相关的部件，而部件树并不关心该值。</p>
<p>使用的上下文就是<code>$context</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tried to call Provider.of&lt;<span class="built_in">dynamic</span>&gt;. This <span class="keyword">is</span> likely a mistake and <span class="keyword">is</span> therefore</span><br><span class="line">unsupported.</span><br><span class="line"></span><br><span class="line">If you want to expose a variable that can be anything, consider changing</span><br><span class="line">`<span class="built_in">dynamic</span>` to `<span class="built_in">Object</span>` instead.</span><br></pre></td></tr></table></figure>

<p>尝试调用<code>Provider.of&lt;dynamic&gt;</code>，这可能是一个错误，因此不被支持。</p>
<p>如果你想暴露一个可以是任何东西的变量，可以考虑将<code>dynamic</code> 改为 <code>Object</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The error that will be thrown if [Provider.of] fails to find a [Provider]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">as an ancestor of the [BuildContext] used.</span></span></span><br></pre></td></tr></table></figure>

<p>如果<code>Provider.of</code>未能找到<code>Provider</code>的祖先，将抛出错误（<code>ProviderNotFoundException</code>）。</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">总结归纳：</span></p>
<p>当我们试图从widget树外部监听提供者公开的值时，我们需要加上属性<code>listen:false</code>。</p>
<p>暴露一个可以是任何东西的变量时，可以考虑将<code>dynamic</code> 改为 <code>Object</code>。</p>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p><code>Consumer</code>只是在<code>Widget</code>中调用了<code>Provider.of</code>，并将其构造实现委托给了构造器。</p>
<blockquote>
<p>sc.</p>
<p>consumer.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Obtains [Provider<span class="language-xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span></span>] from its ancestors and passes its value to [builder].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The [Consumer] widget doesn&#x27;t do any fancy work. It just calls [Provider.of]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">in a new widget, and delegates its <span class="code">`build`</span> implementation to [builder].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[builder] must not be null and may be called multiple times (such as when</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the provided value change).</span></span></span><br></pre></td></tr></table></figure>

<p>从其祖先获取<code>Provider&lt;T&gt;</code>，并将其值传递给<code>builder</code>。</p>
<p><code>Consumer</code>小部件不做任何花哨的工作。它只是在一个新的小部件中调用<code>Provider.of</code>，并将其构建实现委托给<code>Builder</code>。（<a name="target1">后续会用到这句</a>）</p>
<p><code>builder</code>不能为空，并且可以多次调用（例如：当提供的值更改时）。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The [Consumer] widget has two main purposes:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">*</span> It allows obtaining a value from a provider when we don&#x27;t have a</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">  [BuildContext] that is a descendant of said provider, and therefore</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">  cannot use [Provider.of].</span></span></span><br></pre></td></tr></table></figure>

<p><code>Consumer</code>组件有两个主要目的：</p>
<ol>
<li><p>当我们没有<code>BuildContext</code>是该提供者的后代时，它允许从一个提供者（这里是指Consumer）那里获得一个值。因此，不能使用<code>Provider.of</code>。这种情况通常发生在创建提供者的部件是其消费者之一的时候。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">This scenario typically happens when the widget that creates the provider</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">is also one of its consumers, like in the following example:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">@override</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">Widget build(BuildContext context) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  return ChangeNotifierProvider(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    create: (_) =&gt; Foo(),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    child: Text(Provider.of&lt;Foo&gt;(context).value),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  );</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This example will throw a [ProviderNotFoundException], because [Provider.of]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">is called with a [BuildContext] that is an ancestor of the provider.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Instead, we can use the [Consumer] widget, that will call [Provider.of]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">with its own [BuildContext].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Using [Consumer], the previous example will become:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">@override</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">Widget build(BuildContext context) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  return ChangeNotifierProvider(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    create: (_) =&gt; Foo(),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    child: Consumer&lt;Foo&gt;(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">      builder: (_, foo, __) =&gt; Text(foo.value),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    &#125;,</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  );</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">&#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This won&#x27;t throw a [ProviderNotFoundException] and will correctly build the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[Text]. It will also update the [Text] whenever the value <span class="code">`foo`</span> changes.</span></span></span><br></pre></td></tr></table></figure>

<p>这个例子展示了：<code>Provider.of</code>的调用需要<u><em>一个提供者的祖先的</em></u><code>BuildContext</code>，否则就会抛出一个<code>ProviderNotFoundException</code>【提供者未找到异常】。但是，用<code>Consumer</code>组件就能调用它自己<code>BuildContext</code>的<code>Provider.of</code>。这样就不会抛出<code>ProviderNotFoundException</code>【提供者未找到异常】，并且能够正确地生成文本，它也会在值变化时更新文本。（上述官方英文源码结合例子，重组直译）</p>
<p><span style="color:red;font-weight:bold;">个人理解：</span>从这个源码的注释文档可以得出：<code>Consumer</code>组件自带一个<code>BuildContext</code>，并且能够调用自己<code>BuildContext</code>的<code>Provider.of</code>。这一点，从源码中也得到了验证，<code>Consumer</code>不过是对<code>Provider.of</code>的封装优化。</p>
</li>
<li><p>它通过提供更精细化的重建来帮助性能优化。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Unless <span class="code">`listen: false`</span> is passed to [Provider.of], the widget</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">associated with the [BuildContext] passed to [Provider.of] will rebuild</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">whenever the obtained value changes. This is the expected behavior,</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">but sometimes it may rebuild more widgets than needed.</span></span></span><br></pre></td></tr></table></figure>

<p>除非将<code>listen:false</code>传递给<code>Provider.of</code>，否则传递给<code>Provider.of</code>的<code>BuildContext</code>相关的widget将在获得的值改变时重建。这是预期的行为，但有时可能会重建比需要更多的组件。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Here&#x27;s an example:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> @override</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> Widget build(BuildContext context) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   return FooWidget(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     child: BarWidget(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">       bar: Provider.of&lt;Bar&gt;(context),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     ),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   );</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> &#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">In the above code, only <span class="code">`BarWidget`</span> depends on the value returned by</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[Provider.of]. But when <span class="code">`Bar`</span> changes, then both <span class="code">`BarWidget`</span> <span class="emphasis">_and_</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">`FooWidget`</span> will rebuild.</span></span></span><br></pre></td></tr></table></figure>

<p><span style="color:red;font-weight:bold;">个人理解：</span>由<code>Consumer</code>组件的第1个目的可知，<code>Consumer</code>有自己的<code>BuildContext</code>。这个例子中没有<code>Consumer</code>，所以在这里通过<code>Provider.of</code>的调用获取<code>Bar</code>的值时，需要提供者组件的祖先，也就是需要<code>BarWidget</code>的祖先<code>FooWidget</code>中的<code>BuildContext</code>。而在向上查找祖先的<code>BuildContext</code>过程中，为了拿到最新值，依次层级间就都发生了重建。所以在这里，当<code>Bar</code>发生改变时，<code>BarWidget</code>和<code>FooWidget</code>就都发生了重建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Ideally, only <span class="code">`BarWidget`</span> should be rebuilt. One</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">solution to achieve that is to use [Consumer].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">To do so, we will wrap <span class="emphasis">_only_</span> the widgets that depends on a provider into</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">a [Consumer]:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> @override</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> Widget build(BuildContext context) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   return FooWidget(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     child: Consumer&lt;Bar&gt;(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">       builder: (_, bar, __) =&gt; BarWidget(bar: bar),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     ),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   );</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> &#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">In this situation, if <span class="code">`Bar`</span> were to update, only <span class="code">`BarWidget`</span> would rebuild.</span></span></span><br></pre></td></tr></table></figure>

<p><span style="color:red;font-weight:bold;">个人理解：</span>由<code>Consumer</code>组件的第1个目的可知，<code>Consumer</code>有自己的<code>BuildContext</code>。这个例子中有<code>Consumer</code>，所以在获取<code>Bar</code>的值时，直接调用的是<code>Consumer</code>自己的<code>BuildContext</code>的<code>Provider.of</code>。所以当<code>Bar</code>改变时，只有<code>BarWidget</code>发生重建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">But what if it was <span class="code">`FooWidget`</span> that depended on a provider? Example:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> @override</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> Widget build(BuildContext context) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   return FooWidget(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     foo: Provider.of&lt;Foo&gt;(context),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     child: BarWidget(),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   );</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> &#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Using [Consumer], we can handle this kind of scenario using the optional</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">`child`</span> argument:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> @override</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> Widget build(BuildContext context) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   return Consumer&lt;Foo&gt;(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     builder: (_, foo, child) =&gt; FooWidget(foo: foo, child: child),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">     child: BarWidget(),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">   );</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code"> &#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">In that example, <span class="code">`BarWidget`</span> is built outside of [builder]. Then, the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">`BarWidget`</span> instance is passed to [builder] as the last parameter.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This means that when [builder] is called again with new values, a new</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">instance of <span class="code">`BarWidget`</span> will not be created.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This lets Flutter know that it doesn&#x27;t have to rebuild <span class="code">`BarWidget`</span>.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Therefore in such a configuration, only <span class="code">`FooWidget`</span> will rebuild</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">if <span class="code">`Foo`</span> changes.</span></span></span><br></pre></td></tr></table></figure>

<p><span style="color:red;font-weight:bold;">个人理解：</span>由<a href="#target1">前面的源码注释</a>可知，<code>Consumer</code>调用<code>Provider.of</code>的实现委托给了<code>builder</code>。在这个例子中，将子组件实例作为<code>builder</code>的最后一个参数，从而使该子组件被创建在<code>builder</code>之外，这样一来，由于新值改变导致<code>builder</code>被调用时，不会创建该子组件的新实例。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown"><span class="section">## Note:</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The [Consumer] widget can also be used inside [MultiProvider]. To do so, it</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">must return the <span class="code">`child`</span> passed to [builder] in the widget tree it creates.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">MultiProvider(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  providers: [</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    Provider(create: (_) =&gt; Foo()),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    Consumer&lt;Foo&gt;(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">      builder: (context, foo, child) =&gt;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">        Provider.value(value: foo.bar, child: child),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    )</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  ],</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">);</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">See also:</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">  *</span> [Selector], a [Consumer] that can filter updates.</span></span></span><br></pre></td></tr></table></figure>

<p><code>Consumer</code>组件也可以在<code>MultiProvider</code>内使用。为此，它必须在它创建的部件树中返回传递给<code>builder</code>的<code>child</code>。</p>
<p>也请参见：</p>
<p>​    <code>Selector</code>，一个可以过滤更新的<code>Consumer</code>。</p>
</li>
</ol>
</blockquote>
<p><span style="color:red;font-weight:bold;">总结归纳：</span></p>
<p><code>Consumer</code>组件只是对<code>Provider.of</code>的封装；</p>
<p><code>Consumer</code>给后代提供了它自己的<code>BuildContext</code>，因此可以调用<code>Provider.of</code>。</p>
<p><code>Consumer</code>调用<code>Provider.of</code>的实现委托给了<code>builder</code>，因此可以将子组件实例作为<code>builder</code>的最后一个参数，这样，当新值改变导致<code>builder</code>被调用时，不会创建该子组件的新实例。</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p><code>Selector</code>类和<code>Consumer</code>类似，只是对<code>build</code>调用<code>Widget</code>方法时提供更精细的控制，简单点来说，<code>Selector</code>也是一个消费者，它允许你可以从模型中准备定义哪些属性。</p>
<blockquote>
<p>sc.</p>
<p>selector.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">An equivalent to [Consumer] that can filter updates by selecting a limited</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">amount of values and prevent rebuild if they don&#x27;t change.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[Selector] will obtain a value using [Provider.of], then pass that value</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">to <span class="code">`selector`</span>. That <span class="code">`selector`</span> callback is then tasked to return an object</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">that contains only the information needed for <span class="code">`builder`</span> to complete.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">By default, [Selector] determines if <span class="code">`builder`</span> needs to be called again</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">by comparing the previous and new result of <span class="code">`selector`</span> using</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[DeepCollectionEquality] from the package <span class="code">`collection`</span>.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This behavior can be overridden by passing a custom <span class="code">`shouldRebuild`</span> callback.</span></span></span><br></pre></td></tr></table></figure>

<p>相当于<code>Consumer</code>，它可以通过选择有限数量的值来过滤更新，如果这些值没有变化，则防止重建。</p>
<p><code>Selector</code>将使用<code>Provider.of</code>获得一个值，然后将该值传给选择器。该选择器的回调任务是返回一个只包含<code>builder</code>完成所需信息的对象。</p>
<p>默认情况下，<code>Selector</code>通过比较之前的内容来确定是否需要再次调用<code>builder</code>。</p>
<p>这些行为可以通过传递一个自定义的<code>shouldRebuild</code>回调来重写。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown"> <span class="strong">**NOTE**</span>:</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The selected value must be immutable, or otherwise [Selector] may think</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">nothing changed and not call <span class="code">`builder`</span> again.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">As such, it <span class="code">`selector`</span> should return either a collection ([List]/[Map]/[Set]/[Iterable])</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">or a class that override <span class="code">`==`</span>.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">To select multiple values without having to write a class that implements <span class="code">`==`</span>,</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the easiest solution is to use a &quot;Tuple&quot; from [<span class="string">tuple</span>](<span class="link">https://pub.dev/packages/tuple</span>):</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">Selector&lt;Foo, Tuple2&lt;Bar, Baz&gt;&gt;(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  selector: (_, foo) =&gt; Tuple2(foo.bar, foo.baz),</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  builder: (_, data, __) &#123;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">    return Text(&#x27;$&#123;data.item1&#125;  $&#123;data.item2&#125;&#x27;);</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  &#125;</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">)</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">In that example, <span class="code">`builder`</span> will be called again only if <span class="code">`foo.bar`</span> or</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">`foo.baz`</span> changes.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">For generic usage information, see [Consumer].</span></span></span><br></pre></td></tr></table></figure>

<p>所选的值必须是不可改变的，否则<code>Selector</code>可能认为什么都没有改变而不再调用<code>builder</code>。</p>
<p>因此，<code>selector</code>应该返回一个集合（List&#x2F;Map&#x2F;Set&#x2F;Iterable）或者一个覆盖&#x3D;&#x3D;的类。</p>
<p>要选择多个值而不需要写一个实现&#x3D;&#x3D;的类，最简单的解决方案是使用一个<code>Tuple</code>（<a target="_blank" rel="noopener" href="https://pub.dev/packages/tuple%EF%BC%89%E3%80%82">https://pub.dev/packages/tuple）。</a></p>
<p>对于<code>Selector0</code>：</p>
<p>由<code>Selector</code>的构造函数可知，<code>Selector</code>是继承自<code>Selector0</code>的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">A base class for custom [Selector].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">It works with any [InheritedWidget]. Variants like [Selector] and</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[Selector6] are just syntax sugar to use [Selector0] with [Provider.of].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">But it will <span class="strong">**not**</span> work with values</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">coming from anything but [InheritedWidget].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">As such, the following:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```dart</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">T value;</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">return Selector0(</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  selector: (_) =&gt; value,</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">  builder: ...,</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">)</span></span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="code">```</span></span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">will still call <span class="code">`builder`</span> again, even if <span class="code">`value`</span> didn&#x27;t change.</span></span></span><br></pre></td></tr></table></figure>

<p><code>Selector0</code>是自定义<code>Selector</code>的一个基类。</p>
<p>它适用于任何<code>InheritedWidget</code>。像<code>Selector</code>和<code>Selector6</code>这样的变体只是使用<code>Selector0</code>和<code>Provider.of</code>的语法糖。</p>
<p>但对于来自<code>Inheritedwidget</code>以外的任何数值，它都不会起作用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Both <span class="code">`builder`</span> and <span class="code">`selector`</span> must not be <span class="code">`null`</span>.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">A function that builds a widget tree from <span class="code">`child`</span> and the last result of</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[selector].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[builder] will be called again whenever the its parent widget asks for an</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">update, or if [selector] return a value that is different from the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">previous one using [operator==].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Must not be <span class="code">`null`</span>.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">A function that obtains some [InheritedWidget] and map their content into</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">a new object with only a limited number of properties.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The returned object must implement [operator==].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Must not be <span class="code">`null`</span></span></span></span><br></pre></td></tr></table></figure>

<p><code>builder</code>和<code>selector</code>都必须不为空。</p>
<p><code>builder</code>：一个函数，它从<code>child</code>和<code>selector</code>的最后一个结果，构造一个组件树。当它的父组件要求更新时，或者如果<code>selector</code>使用<code>operator==</code>返回一个与前一个不同的值。必须不为空。</p>
<p><code>selector</code>：一个获取<code>InheritedWidget</code>的函数，并将其内容映射到一个只有有限属性的新对象。返回的对象必须实现<code>operator==</code>。必须不为空。</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">总结归纳：</span></p>
<p><code>Selector</code>与<code>Consumer</code>类似。</p>
<p><code>Selector</code>是<code>Selector0</code>和<code>Provider</code>的一个语法糖。</p>
<p><code>Selector0</code>只对<code>Inheritedwidget</code>内的数据起作用。</p>
<p><code>Selector</code>的两大参数都必须不为空。</p>
<h4 id="InheritedContext"><a href="#InheritedContext" class="headerlink" title="InheritedContext"></a>InheritedContext</h4><p><code>InheritedContext</code>是<code>Provider</code>内置扩展了<code>BuildContext</code>。</p>
<blockquote>
<p>sc.</p>
<p>inherited_context.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">A [BuildContext] associated to an [InheritedProvider].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">It an extra [markNeedsNotifyDependents] method and the exposed value.</span></span></span><br></pre></td></tr></table></figure>

<p>一个与<code>InheritedProvider</code>相关的<code>BuildContext</code>，它有一个额外的<code>markNeedsNotifyDependents</code>方法和暴露的值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The current value exposed by [InheritedProvider].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This property is lazy loaded, and reading it the first time may trigger</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">some side-effects such as creating a [T] instance or start a subscription.</span></span></span><br></pre></td></tr></table></figure>

<p>由<code>InheritedProvider</code>暴露当前值。</p>
<p>这个属性是懒加载的，第一次读取它可能会触发一些副作用，如创建一个<code>T</code>实例或启动一个订阅。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Marks the [InheritedProvider] as needing to update dependents.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This bypass [InheritedWidget.updateShouldNotify] and will force widgets</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">that depends on [T] to rebuild.</span></span></span><br></pre></td></tr></table></figure>

<p>将<code>InheritedProvider</code>标记为按需更新依赖项。</p>
<p>这绕过了<code>InheritedWidget.updateShouldNotify</code>，将迫使依赖于<code>T</code>的widget重新构建。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Whether <span class="code">`setState`</span> was called at least once or not.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">It can be used by [DeferredStartListening] to differentiate between the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">very first listening, and a rebuild after <span class="code">`controller`</span> changed.</span></span></span><br></pre></td></tr></table></figure>

<p>对于<code>InheritedProvider</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">A generic implementation of an [InheritedWidget].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Any descendant of this widget can obtain <span class="code">`value`</span> using [Provider.of].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Do not use this class directly unless you are creating a custom &quot;Provider&quot;.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Instead use [Provider] class, which wraps [InheritedProvider].</span></span></span><br></pre></td></tr></table></figure>

<p><code>InheritedWidget</code>的通用实现。</p>
<p>此组件的任何后代都可以使用<code>Provider.of</code>获取值。</p>
<p>不要直接使用这个类，除非你正在创建一个自定义的提供者。而要使用<code>Provider</code>类，它包装了<code>InheritedProvider</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">See also:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet"> -</span> [DeferredInheritedProvider], a variant of this object where the provided</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   object and the created object are two different entity.</span></span></span><br></pre></td></tr></table></figure>

<p>另请参阅：</p>
<p><code>DeferredInheritedProvider</code>，这个对象（即InheritedWidget）的变体，其中提供的对象和创建的对象是两个不同的实体。</p>
<p>sc.</p>
<p>deferred_inherited_provider.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">An [InheritedProvider] where the object listened is <span class="emphasis">_not_</span> the object</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">emitted.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">For example, for a stream provider, we&#x27;ll want to listen to <span class="code">`Stream&lt;T&gt;`</span>,</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">but expose <span class="code">`T`</span> not the [Stream].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">See also:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet"> -</span> [InheritedProvider], a variant of this object where the provider object and</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   the created object are the same.</span></span></span><br></pre></td></tr></table></figure>

<p>一个<code>InheritedProvider</code>，其中被监听的对象不是被触发的对象。</p>
<p>例如，对一个<code>Stream</code>提供者来说，我们想监听<code>Stream&lt;T&gt;</code>，但暴露的<code>T</code>不是<code>Stream</code>。</p>
<p>另请参阅：</p>
<p><code>InheritedProvider</code>，此对象的变体，提供者对象和创建的对象是相同的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Lazily create an object automatically disposed when</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[DeferredInheritedProvider] is removed from the tree.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The object create will be listened using <span class="code">`startListening`</span>, and its content</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">will be exposed to <span class="code">`child`</span> and its descendants.</span></span></span><br></pre></td></tr></table></figure>

<p>当<code>DeferredInheritedProvider</code>从树中移除时，延迟创建一个自动释放的对象。</p>
<p>创建的对象将使用<code>startListening</code>进行监听，并且它的内容将暴露给子孙后代。</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">总结归纳：</span></p>
<p><code>InheritedContext</code>，它是与<code>InheritedProvider</code>相关的<code>BuildContext</code>。</p>
<p><code>InheritedContext</code>由<code>InheritedProvider</code>暴露相关值。</p>
<p><code>InheritedProvider</code>，这个组件的任何后代都可以使用<code>Provider.of</code>获取值。</p>
<p>官方建议使用<code>Provider</code>，它包装了<code>InheritedProvider</code>。</p>
<h4 id="扩展：BuildContext"><a href="#扩展：BuildContext" class="headerlink" title="扩展：BuildContext"></a>扩展：BuildContext</h4><blockquote>
<p>最后再来看看<a name='target2'>BuildContext</a>：</p>
<p>sc.</p>
<p>framework.dart</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">A handle to the location of a widget in the widget tree.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">This class presents a set of methods that can be used from</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[StatelessWidget.build] methods and from methods on [State] objects.</span></span></span><br></pre></td></tr></table></figure>

<p>在组件树中小部件的位置的方法。【rf. handle n. （解决问题的）方法、途径】</p>
<p>这个类提供了一组方法，可在<code>StatelessWidget.build</code>方法和<code>State</code>对象的方法中使用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">[BuildContext] objects are passed to [WidgetBuilder] functions (such as</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[StatelessWidget.build]), and are available from the [State.context] member.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Some static functions (e.g. [showDialog], [Theme.of], and so forth) also</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">take build contexts so that they can act on behalf of the calling widget, or</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">obtain data specifically for the given context.</span></span></span><br></pre></td></tr></table></figure>

<p><code>BuildContext</code>对象被传递给<code>WidgetBuilder</code>函数（比如<code>StatelessWidget.build</code>），并且可以从<code>State.context</code>成员中获得。一些静态函数（比如<code>showDialog</code>、<code>Theme.of</code>等）也接受构建上下文，以便它们可以代表调用的小部件采取行动，或者为给定的上下文获得专门的数据。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Each widget has its own [BuildContext], which becomes the parent of the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">widget returned by the [StatelessWidget.build] or [State.build] function.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">(And similarly, the parent of any children for [RenderObjectWidget]s.)</span></span></span><br></pre></td></tr></table></figure>

<p>每个小组件都有自己的<code>BuildContext</code>，它成为<code>StatelessWidget.build</code>或<code>State.build</code>函数所返回组件的父组件。（同样，对于<code>RenderObjectWidget</code>，它是任何子组件的父组件。）</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">In particular, this means that within a build method, the build context of</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the widget of the build method is not the same as the build context of the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">widgets returned by that build method. This can lead to some tricky cases.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">For example, [Theme.of(context)] looks for the nearest enclosing [Theme] of</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the given build context. If a build method for a widget Q includes a [Theme]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">within its returned widget tree, and attempts to use [Theme.of] passing its</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">own context, the build method for Q will not find that [Theme] object. It</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">will instead find whatever [Theme] was an ancestor to the widget Q. If the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">build context for a subpart of the returned tree is needed, a [Builder]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">widget can be used: the build context passed to the [Builder.builder]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">callback will be that of the [Builder] itself.</span></span></span><br></pre></td></tr></table></figure>

<p>特别是，这意味着在一个构建方法中，该构建方法的组件构建的上下文与该构建方法返回的小组件构建的上下文不一样。这可能会导致一些棘手的情况。例如，<code>Theme.of(context)</code>查找给定上下文中最近封闭的<code>Theme</code>。</p>
<p>如果一个小部件Q的构建方法在其返回的小部件树中包括一个<code>Theme</code>，并尝试使用<code>Theme.of</code>传递其自己的上下文。Q的构建方法将不会找到那个<code>Theme</code>对象。相反，它会找到每一个小组件Q的祖先的<code>Theme</code>。【rf. whatever pron. 任何;  每一;】如果需要为返回的树的子部分构建上下文，<code>Builder</code>组件可能被用到：传递给<code>Builder.builder</code>回调的构建上下文将是<code>Builder</code>本身的构建上下文。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The [BuildContext] for a particular widget can change location over time as</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the widget is moved around the tree. Because of this, values returned from</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">the methods on this class should not be cached beyond the execution of a</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">single synchronous function.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[BuildContext] objects are actually [Element] objects. The [BuildContext]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">interface is used to discourage direct manipulation of [Element] objects.</span></span></span><br></pre></td></tr></table></figure>

<p>一个特定组件的<code>BuildContext</code>可以随时间的推移，随着组件在树上的移动而改变位置。正因为如此，从这个类上的方法返回的值不应该在执行单个同步函数之后被缓存。</p>
<p><code>BuildContext</code>对象实际上是<code>Element</code>对象。<code>BuildContext</code>接口被用来阻止对<code>Element</code>对象的直接操作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The current configuration of the [Element] that is this [BuildContext].</span></span></span><br></pre></td></tr></table></figure>

<p><code>Element</code>的当前配置就是<code>BuildContext</code>。</p>
<p>sc. framework.dart 中涉及到<code>BuildContext</code>的直译与总结：</p>
<p>在<code>GlobalKey</code>部分中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Global keys uniquely identify elements. Global keys provide access to other</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">objects that are associated with those elements, such as [BuildContext].</span></span></span><br></pre></td></tr></table></figure>

<p>全局键可以唯一地识别元素。全局键提供了对与这些元素关联的其他对象的访问，例如<code>BuildContext</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The build context in which the widget with this key builds.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The current context is null if there is no widget in the tree that matches</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">this global key.</span></span></span><br></pre></td></tr></table></figure>

<p>具有此键的组件在其中生成的构建上下文。</p>
<p>如果树上没有匹配这个全局键的组件，则当前上下文为空。</p>
<p>在<code>StatelessWidget</code>部分中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The framework calls this method when this widget is inserted into the tree</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">in a given [BuildContext] and when the dependencies of this widget change</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">(e.g., an [InheritedWidget] referenced by this widget changes). This</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">method can potentially be called in every frame and should not have any side</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">effects beyond building a widget.</span></span></span><br></pre></td></tr></table></figure>

<p>当这个小组件在给定的<code>BuildContext</code>中被插入到树中，以及这个组件的依赖关系发生变化（例如，这个组件引用的<code>InheritedWidget</code>发生变化）时，框架将调用此方法。此方法有可能在每一帧中被调用，除了构建一个组件之外，不会有任何副作用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Typically implementations return a newly created constellation of widgets</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">that are configured with information from this widget&#x27;s constructor and</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">from the given [BuildContext].</span></span></span><br></pre></td></tr></table></figure>

<p>通常情况下，实现会返回一个新创建的一系列组件，这些小组件是用来自这个组件的构造函数和给定的<code>BuildContext</code>的信息配置的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The given [BuildContext] contains information about the location in the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">tree at which this widget is being built. For example, the context</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">provides the set of inherited widgets for this location in the tree. A</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">given widget might be built with multiple different [BuildContext]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">arguments over time if the widget is moved around the tree or if the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">widget is inserted into the tree in multiple places at once.</span></span></span><br></pre></td></tr></table></figure>

<p>给定的<code>BuildContext</code>包含了该组件在树中被构建的位置信息。例如，该上下文提供了树中该位置的继承组件的集合。如果该部件在树中被移动，或者该部件被同时插入到树中的多个位置，那么该部件可能会随着时间的推移被构建多个不同的<code>BuildContext</code>参数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The implementation of this method must only depend on:</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">*</span> the fields of the widget, which themselves must not change over time,</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">  and</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">*</span> any ambient state obtained from the <span class="code">`context`</span> using</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">  [BuildContext.dependOnInheritedWidgetOfExactType].</span></span></span><br></pre></td></tr></table></figure>

<p>此方法（build）的实现必须仅依赖于：</p>
<p>小部件的字段，它们本身不能随着时间的推移而改变，并且可以从上下文中使用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>获得任何环境状态。</p>
<p>在<code>StatefulWidget</code>部分中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Stateful widgets are useful when the part of the user interface you are</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">describing can change dynamically, e.g. due to having an internal</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">clock-driven state, or depending on some system state. For compositions that</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">depend only on the configuration information in the object itself and the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[BuildContext] in which the widget is inflated, consider using</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[StatelessWidget].</span></span></span><br></pre></td></tr></table></figure>

<p>当你所描述的用户界面的部分可以动态变化时，例如，由于有一个内部时钟驱动的状态，或者取决于一些系统状态，有状态的组件是还有用的。对于只依赖对象本身和<code>BuildContext</code>的配置信息的组件，可以考虑使用<code>StatelessWidget</code>。</p>
<p>对于<code>State</code>部分中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet"> *</span> The newly created [State] object is associated with a [BuildContext].</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   This association is permanent: the [State] object will never change its</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   [BuildContext]. However, the [BuildContext] itself can be moved around</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   the tree along with its subtree. At this point, the [State] object is</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   considered [mounted].</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet"> *</span> The framework calls [initState]. Subclasses of [State] should override</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   [initState] to perform one-time initialization that depends on the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   [BuildContext] or the widget, which are available as the [context] and</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   [widget] properties, respectively, when the [initState] method is</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   called.</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet"> *</span> The framework calls [didChangeDependencies]. Subclasses of [State] should</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   override [didChangeDependencies] to perform initialization involving</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   [InheritedWidget]s. If [BuildContext.dependOnInheritedWidgetOfExactType] is</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   called, the [didChangeDependencies] method will be called again if the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">   inherited widgets subsequently change or if the widget moves in the tree.</span></span></span><br></pre></td></tr></table></figure>

<p>新创建的<code>State</code>对象与<code>BuildContext</code>相关联。这种关联是永久性的：<code>State</code>对象永远不会改变它的<code>BuildContext</code>。然而，<code>BuildContext</code>本身可以和它的子树一起在树上移动。在这一点上，<code>State</code>对象被认为是被挂载。<br>框架调用<code>initState</code>。<code>State</code>的子类应该覆盖<code>initState</code>来执行一次性的初始化，这取决于<code>BuildContext</code>或上下文，当<code>initState</code>方法被调用时，它们分别作为上下文和组件属性可使用。<br>框架调用<code>didChangeDependency</code>，<code>State</code>的子类应该重写<code>didChangeDependency</code>以执行涉及<code>InheritedWidget</code>的初始化。如果<code>BuildContext.dependOnInheritedWidgetOfExactType</code>被调用，那么如果继承的组件随后发生变化或者widget在树上移动，<code>didChangeDependencies</code>方法将被再次调用。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The framework associates [State] objects with a [BuildContext] after</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">creating them with [StatefulWidget.createState] and before calling</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[initState]. The association is permanent: the [State] object will never</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">change its [BuildContext]. However, the [BuildContext] itself can be moved</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">around the tree.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">After calling [dispose], the framework severs the [State] object&#x27;s</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">connection with the [BuildContext].</span></span></span><br></pre></td></tr></table></figure>

<p>在用<code>StatefulWidget.createState</code>创建<code>State</code>对象后 和 在调用<code>initState</code>前，框架将<code>State</code>对象与<code>BuildContext</code>关联起来。这种关联是永久性的：<code>State</code>对象将永远不会改变其<code>BuildContext</code>。但是，<code>BuildContext</code>本身可以在树中移动。</p>
<p>在调用<code>dispose</code>后，框架切断了<code>State</code>对象与<code>BuildContext</code>的联系。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Whether this [State] object is currently in a tree.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">After creating a [State] object and before calling [initState], the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">framework &quot;mounts&quot; the [State] object by associating it with a</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[BuildContext]. The [State] object remains mounted until the framework</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">calls [dispose], after which time the framework will never ask the [State]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">object to [build] again.</span></span></span><br></pre></td></tr></table></figure>

<p>在创建一个<code>State</code>对象之后 和 在调用<code>initState</code>之前，框架通过<code>State</code>对象与一个<code>BuildContext</code>相关联来进行挂载。<code>State</code>对象将保持挂载状态，直到框架调用<code>dispose</code>为止。在此之后，框架将永远不会要求该<code>State</code>对象进行重构。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">You cannot use [BuildContext.dependOnInheritedWidgetOfExactType] from this</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">method. However, [didChangeDependencies] will be called immediately</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">following this method, and [BuildContext.dependOnInheritedWidgetOfExactType] can</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">be used there.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Implementations of this method should start with a call to the inherited</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">method, as in <span class="code">`super.initState()`</span>.</span></span></span><br></pre></td></tr></table></figure>

<p>你不能从这个方法（<code>initState</code>）中使用<code>BuildContext.dependOInheritedWidgetOfExactType</code>。然而，<code>didChangeDependencies</code>将在这个方法之后立即被调用，并且<code>BuildContext.dependOInheritedWidgetOfExactType</code>可以在那儿被使用。这个方法的实现应该从调用继承方法开始，如<code>super.initState()</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Typically implementations return a newly created constellation of widgets</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">that are configured with information from this widget&#x27;s constructor, the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">given [BuildContext], and the internal state of this [State] object.</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">The given [BuildContext] contains information about the location in the</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">tree at which this widget is being built. For example, the context</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">provides the set of inherited widgets for this location in the tree. The</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[BuildContext] argument is always the same as the [context] property of</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">this [State] object and will remain the same for the lifetime of this</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">object. The [BuildContext] argument is provided redundantly here so that</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">this method matches the signature for a [WidgetBuilder].</span></span></span><br></pre></td></tr></table></figure>

<p>通常，实现返回一个新创建的一系列小组件，这些小组件的配置来自该组件的构造函数、给定的<code>BuildContext</code>以及这个<code>State</code>对象的内部状态。</p>
<p>给定的<code>BuildContext</code>包含关于该组件正在被构建的树中的位置信息。<code>BuildContext</code>参数总是与这个<code>State</code>对象的<code>context</code>属性相同，并且在这个对象的生命周期内保持不变。这里提供的<code>BuildContext</code>参数是多余的，以便此方法与<code>WidgetBuilder</code>的签名相匹配。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Putting a <span class="code">`Widget build(BuildContext context)`</span> method on [State] rather</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">than putting a <span class="code">`Widget build(BuildContext context, State state)`</span> method</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">on [StatefulWidget] gives developers more flexibility when subclassing</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[StatefulWidget].</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">For example, [AnimatedWidget] is a subclass of [StatefulWidget] that</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">introduces an abstract <span class="code">`Widget build(BuildContext context)`</span> method for its</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">subclasses to implement. If [StatefulWidget] already had a [build] method</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">that took a [State] argument, [AnimatedWidget] would be forced to provide</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">its [State] object to subclasses even though its [State] object is an</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">internal implementation detail of [AnimatedWidget].</span></span></span><br></pre></td></tr></table></figure>

<p>将一个<code>Widget build(BuildContext context)</code>方法放在<code>State</code>上，而不是将<code>Widget build(BuildContext context, State state)</code>方法放在<code>StatefulWidget</code>上，这为开发人员在子类化<code>StatefulWidget</code>提供了更多的灵活性。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">This method is also called immediately after [initState]. It is safe to</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">call [BuildContext.dependOnInheritedWidgetOfExactType] from this method.</span></span></span><br></pre></td></tr></table></figure>

<p>这个方法（<code>didChangeDependencies</code>）也会在<code>initState</code>之后立即调用。从这个方法中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>是安全的。</p>
<p>在<code>InheritedWidget</code>中的部分：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">To obtain the nearest instance of a particular type of inherited widget from</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">a build context, use [BuildContext.dependOnInheritedWidgetOfExactType].</span></span></span><br></pre></td></tr></table></figure>

<p>要从构建上下文中获得一个特定类型的继承组件的最近实例，请使用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">The convention is to provide a static method <span class="code">`of`</span> on the [InheritedWidget]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">which does the call to [BuildContext.dependOnInheritedWidgetOfExactType]. This</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">allows the class to define its own fallback logic in case there isn&#x27;t</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">a widget in scope.</span></span></span><br></pre></td></tr></table></figure>

<p>惯例是在<code>InheritedWidget</code>上提供一个静态方法of，它将对<code>BuildContext.dependOnInheritedWidgetOfExactType</code>进行调用。这允许类在范围内没有组件的情况下定义自己的回退逻辑。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Occasionally, the inherited widget is an implementation detail of another</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">class, and is therefore private. The <span class="code">`of`</span> method in that case is typically</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">put on the public class instead. For example, [Theme] is implemented as a</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">[StatelessWidget] that builds a private inherited widget; [Theme.of] looks</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">for that inherited widget using [BuildContext.dependOnInheritedWidgetOfExactType]</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">and then returns the [ThemeData].</span></span></span><br></pre></td></tr></table></figure>

<p>有时，继承的组件是另一个类的实现细节，因此是私有的。这种情况下的<code>of</code>方法通常放在公共类上。例如，<code>Theme</code>被实现为一个<code>StateleeWidget</code>，它构建一个私有的继承小组件；使用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>查找继承的小组件，然后返回<code>ThemeData</code>。</p>
<p>在<code>ElementVisitor</code>部分中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">Signature for the callback to [BuildContext.visitChildElements].</span></span></span><br></pre></td></tr></table></figure>

<p>对<code>BuildContext.visitChildElements</code>的回调进行签名。</p>
<p>最后：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;This error happens if you call dependOnInheritedWidgetOfExactType() on the &#x27;</span></span><br><span class="line"><span class="string">&#x27;BuildContext for a widget that no longer appears in the widget tree &#x27;</span></span><br><span class="line"><span class="string">&#x27;(e.g., whose parent widget no longer includes the widget in its &#x27;</span></span><br><span class="line"><span class="string">&#x27;build). This error can occur when code calls &#x27;</span></span><br><span class="line"><span class="string">&#x27;dependOnInheritedWidgetOfExactType() from a timer or an animation callback.&#x27;</span>,</span><br></pre></td></tr></table></figure>

<p>如果你在<code>BuildContext</code>上为一个不再出现在组件树上的组件调用<code>dependOnInheritedWidgetOfExactType()</code>（例如它的父组件不再将该组件纳入它的<code>build</code>中），这个错误就会发生。当代码从一个计时器或动画回调中调用<code>dependOnInheritedWidgetOfExactType()</code>时，就会发生这个错误。</p>
</blockquote>
<p><span style="color:red;font-weight:bold;">总结归纳：</span></p>
<p><code>BuildContext</code>对象实际上是<code>Element</code>对象。</p>
<p><code>BuildContext</code>接口被用来阻止对<code>Element</code>对象的直接操作。</p>
<p>给定的<code>BuildContext</code>包含了该组件在树中被构建的位置信息。如果该部件在树中被移动，或者该部件被同时插入到树中的多个位置，那么该部件可能会随着时间的推移被构建多个不同的<code>BuildContext</code>参数。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">夜行书生</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yexingshusheng.com/flutter-zhuang-tai-guan-li-zhi-si-da-xiao-fei-zhe-shi-yong-fen-xi.html">https://yexingshusheng.com/flutter-zhuang-tai-guan-li-zhi-si-da-xiao-fei-zhe-shi-yong-fen-xi.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yexingshusheng.com">夜行书生</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/202205/">202205</a><a class="post-meta__tags" href="/tags/flutter/">flutter</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/xgyxss/picgo@main/img/hexo/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://cdn.jsdelivr.net/gh/xgyxss/picgo@main/img/hexo/wechatpay.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-6211fe3048a47848" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/mbti-ren-ge-ce-shi.html"><i class="fa fa-chevron-left">  </i><span>MBTI人格测试</span></a></div><div class="next-post pull-right"><a href="/flutter-zhuang-tai-guan-li-zhi-ba-da-ti-gong-zhe-shi-yong-fen-xi.html"><span>flutter状态管理之八大提供者使用分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = '' == 'true';
var verify = '' == 'true';
var record_ip = 'true' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = ''.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'zTNuHDTR09rm7hWr9wV6Rhuw-gzGzoHsz',
  appKey:'xoMEOMRH0kzg9UGJ6koAgm8X',
  placeholder:'Please leave your footprints.',
  avatar:'',
  guest_info:guest_info,
  pageSize:'',
  lang: ''
})</script></div></div><footer class="footer-bg" style="background-image: url(https://cdn.jsdelivr.net/gh/xgyxss/picgo@main/img/hexo/hexo-bg.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 By 夜行书生</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text"><span>It is better to be excellent than to be envious.</span><br><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">鄂ICP备2020021979号</a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/algolia.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>